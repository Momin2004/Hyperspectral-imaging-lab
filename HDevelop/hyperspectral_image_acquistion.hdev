<?xml version="1.0" encoding="UTF-8"?>
<hdevelop file_version="1.2" halcon_version="24.05.0.0">
<procedure name="main">
<interface/>
<body>
<c>* </c>
<c>* Example for the usage of a hyperspectral linescan camera</c>
<c>* like the Specim FX series in HALCON.</c>
<c>* </c>
<c>* This example shows how to acquire frames from the camera</c>
<c>* and reorder the data for usage as multi-channel images.</c>
<c>* </c>
<c>* In order to generate a HALCON multi-channel image</c>
<c>* from their data, a certain number of frames needs</c>
<c>* to be acquired and reordered. The first line of all frames</c>
<c>* makes up the first channel of the resulting HALCON image.</c>
<c>* The second line of all frames makes up the second channel</c>
<c>* and so on. The number of frames makes up the height</c>
<c>* of the resulting image and needs to be specified:</c>
<l>Height := 480</l>
<c>* </c>
<l>Name := 'GigEVision2'</l>
<l>Device := 'default'</l>
<c>* Image Acquisition 03: Code generated by Image Acquisition 03</c>
<c>* Image Acquisition 01: Code generated by Image Acquisition 01</c>
<l>open_framegrabber ('GigEVision2', 0, 0, 0, 0, 0, 0, 'progressive', -1, 'default', 'force_ip=192.168.0.5/70:F8:E7:B0:10:7B/192.168.0.144/255.255.255.0', 'false', 'default', '', 0, -1, AcqHandle)</l>
<l>get_framegrabber_param(AcqHandle, 'available_param_names', Value)</l>
<l>get_framegrabber_param(AcqHandle, 'AcquisitionFrameRate', Value1)</l>
<l>set_framegrabber_param(AcqHandle, 'AcquisitionFrameRate', 70)</l>
<l>create_message_queue (QueueHandle)</l>
<c>* </c>
<c>* Reflectance transformation is needed to remove the effect</c>
<c>* of the camera optics and sensor from the acquired image.</c>
<c>* Another important reason is the need to allow for and correct</c>
<c>* the effect of different illumination on the measurements.</c>
<c>* For full instructions about this process,</c>
<c>* please refer to the camera manufacturer.</c>
<c>* This example only describes the arithmetic part of it:</c>
<c>* Reflectance = (Image - RefDark)/(RefWhite - RefDark)</c>
<c>* In theory, one line of reference is enough</c>
<c>* but some more lines can compensate outliers:</c>
<l>NumRefLines := 8</l>
<c>* </c>
<l>dev_get_window (WindowHandle)</l>
<l>if (WindowHandle == -1)</l>
<l>    dev_open_window (0, 0, 512, 512, 'black', WindowHandle)</l>
<l>endif</l>
<l>String := 'Dark reference for reflectance transformation:\n' + 'Until the next instruction, completely cover the lens.\n' + 'For full instructions, please refer to the camera manufacturer.'</l>
<l>dev_disp_text (String, 'window', 'top', 'left', 'black', [], [])</l>
<l>disp_continue_message (WindowHandle, 'black', 'true')</l>
<l>stop ()</l>
<c>* Dark reference.</c>
<l>grab_line_frames (AcqHandle, 1, NumRefLines, QueueHandle)</l>
<l>reorder_line_frames (RefDark, QueueHandle)</l>
<l>get_image_size (RefDark, Samples, NumRefLines)</l>
<l>zoom_image_size (RefDark, RefDark, Samples, 1, 'constant')</l>
<l>zoom_image_size (RefDark, RefDark, Samples, Height, 'constant')</l>
<l>*write_object(RefDark, 'C:/Users/jdeca/OneDrive/Bureaublad/Output 13-12/direct_ouput/dark.tiff')</l>
<l>write_image(RefDark, 'tiff', 0, 'C:/Users/jdeca/OneDrive/Bureaublad/Output 13-12/direct_ouput/slecht/dark.tiff')</l>
<l>dev_clear_window ()</l>
<l>String := 'White reference for reflectance transformation:\n' + 'Uncover the lens and place a white reference target over the full width.\n' + 'For full instructions, please refer to the camera manufacturer.'</l>
<l>dev_disp_text (String, 'window', 'top', 'left', 'black', [], [])</l>
<l>disp_continue_message (WindowHandle, 'black', 'true')</l>
<l>stop ()</l>
<c>* White reference.</c>
<l>grab_line_frames (AcqHandle, 1, NumRefLines, QueueHandle)</l>
<l>reorder_line_frames (RefWhite, QueueHandle)</l>
<l>get_image_size (RefWhite, Samples, NumRefLines)</l>
<l>zoom_image_size (RefWhite, RefWhite, Samples, 1, 'constant')</l>
<l>zoom_image_size (RefWhite, RefWhite, Samples, Height, 'constant')</l>
<l>*write_object(RefWhite, 'C:/Users/jdeca/OneDrive/Bureaublad/Output 13-12/direct_ouput/white')</l>
<l>write_image(RefWhite, 'tiff', 0, 'C:/Users/jdeca/OneDrive/Bureaublad/Output 13-12/direct_ouput/slecht/white.tiff')</l>
<c></c>
<c>* </c>
<c>* Precalculate the denominator of the reflectance transformation.</c>
<l>sub_image (RefWhite, RefDark, RefWhiteMinusRefDark, 1, 0)</l>
<l>convert_image_type (RefWhiteMinusRefDark, RefWhiteMinusRefDark, 'real')</l>
<c>* </c>
<l>dev_clear_window ()</l>
<l>String := 'Now the actual acquisition of images can begin.\n' + 'Remember that you need linear movement for reasonable results.'</l>
<l>dev_disp_text (String, 'window', 'top', 'left', 'black', [], [])</l>
<l>disp_continue_message (WindowHandle, 'black', 'true')</l>
<l>stop ()</l>
<l>dev_clear_window ()</l>
<l>dev_disp_text ('Acquiring...', 'window', 'top', 'left', 'black', [], [])</l>
<c>* Increase NumImages if you want to acquire in a loop.</c>
<l>NumImages := 1</l>
<c>* </c>
<c>* The acquisition of the frames and the reordering</c>
<c>* are parallelized for speedup.</c>
<l>dev_update_off ()</l>
<l>par_start&lt;ThreadID&gt; : grab_line_frames (AcqHandle, NumImages, Height, QueueHandle)</l>
<l>for IndexImages := 1 to NumImages by 1</l>
<c>    * If the number of queued messages increases,</c>
<c>    * we might get a memory problem on long term.</c>
<c>    * In that case, reduce the camera frame rate</c>
<c>    * so the reordering part can keep up.</c>
<l>    get_message_queue_param (QueueHandle, 'message_num', MessageNum)</l>
<l>    if (MessageNum &gt; 1)</l>
<l>        stop ()</l>
<l>    endif</l>
<l>    reorder_line_frames (Image, QueueHandle)</l>
<c>    * Do the rest of the reflectance transformation.</c>
<l>    sub_image (Image, RefDark, ImageMinusRefDark, 1, 0)</l>
<l>    convert_image_type (ImageMinusRefDark, ImageMinusRefDark, 'real')</l>
<l>    div_image (ImageMinusRefDark, RefWhiteMinusRefDark, Reflectance, 1, 0)</l>
<l>    dev_display (Reflectance)</l>
<c>    * </c>
<c>    * Work with the reflectance...</c>
<l>endfor</l>
<c>* Infinite loop waiting for "run" press to acquire one image at a time.</c>
<l>NumImages := 1</l>
<l>ImageCounter := 1</l>
<c></c>
<l>while (true)</l>
<l>    dev_update_off ()</l>
<l>    dev_clear_window ()</l>
<l>    dev_disp_text ('Acquiring...', 'window', 'top', 'left', 'black', [], [])</l>
<l>    par_start&lt;ThreadID&gt; : grab_line_frames (AcqHandle, NumImages, Height, QueueHandle)</l>
<l>    for IndexImages := 1 to NumImages by 1</l>
<l>        get_message_queue_param (QueueHandle, 'message_num', MessageNum)</l>
<l>        if (MessageNum &gt; 1)</l>
<l>            stop ()</l>
<l>        endif</l>
<l>        reorder_line_frames (Image, QueueHandle)</l>
<c>        * Reflectance transformation</c>
<l>        sub_image (Image, RefDark, ImageMinusRefDark, 1, 0)</l>
<l>        convert_image_type (ImageMinusRefDark, ImageMinusRefDark, 'real')</l>
<l>        div_image (ImageMinusRefDark, RefWhiteMinusRefDark, Reflectance, 1, 0)</l>
<l>        dev_display (Reflectance)</l>
<c>        * Save the reflectance image with an incremented file name</c>
<l>        *write_object(Reflectance, 'C:/Users/jdeca/OneDrive/Bureaublad/Output 13-12/direct_ouput/reflectance_image_' + ImageCounter)</l>
<l>        write_image(Reflectance, 'tiff', 0, 'C:/Users/jdeca/OneDrive/Bureaublad/Output 13-12/direct_ouput/slecht/reflectance_image_' + ImageCounter + '.tiff')</l>
<l>        ImageCounter := ImageCounter + 1</l>
<l>    endfor</l>
<l>    dev_update_on ()</l>
<l>    stop () </l>
<l>endwhile</l>
<c></c>
<l>par_join (ThreadID)</l>
<l>dev_update_on ()</l>
<l>close_framegrabber (AcqHandle)</l>
</body>
<docu id="main">
<parameters/>
</docu>
</procedure>
<procedure name="reorder_line_frames">
<interface>
<oo>
<par name="Image" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="QueueHandle" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* Pick up the acquired lines.</c>
<l>dequeue_message (QueueHandle, 'timeout', 'infinite', MessageHandle)</l>
<l>get_message_obj (Lines, MessageHandle, 'lines')</l>
<l>get_message_tuple (MessageHandle, 'bands', Bands)</l>
<l>get_message_tuple (MessageHandle, 'samples', Samples)</l>
<c>* </c>
<c>* Reorder them.</c>
<l>gen_empty_obj (Channels)</l>
<l>for Channel := 0 to Bands - 1 by 1</l>
<l>    crop_rectangle1 (Lines, LinesChannel, Channel, 0, Channel, Samples - 1)</l>
<l>    tile_images (LinesChannel, ImageChannel, 1, 'vertical')</l>
<l>    concat_obj (Channels, ImageChannel, Channels)</l>
<l>endfor</l>
<l>channels_to_image (Channels, Image)</l>
<l>return ()</l>
</body>
<docu id="reorder_line_frames">
<parameters>
<parameter id="Image"/>
<parameter id="QueueHandle"/>
</parameters>
</docu>
</procedure>
<procedure name="grab_line_frames">
<interface>
<ic>
<par name="AcqHandle" base_type="ctrl" dimension="0"/>
<par name="NumImages" base_type="ctrl" dimension="0"/>
<par name="Height" base_type="ctrl" dimension="0"/>
<par name="QueueHandle" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>grab_image_start (AcqHandle, -1)</l>
<l>for IndexImages := 1 to NumImages by 1</l>
<c>    * Acquire the lines of an image.</c>
<l>    gen_empty_obj (Lines)</l>
<l>    for IndexLines := 1 to Height by 1</l>
<l>        grab_image_async (Frame, AcqHandle, -1)</l>
<l>        concat_obj (Lines, Frame, Lines)</l>
<l>    endfor</l>
<l>    get_image_size (Frame, Samples, Bands)</l>
<c>    * </c>
<c>    * Store them in a message for the reordering thread to pick up.</c>
<l>    create_message (MessageHandle)</l>
<l>    set_message_obj (Lines, MessageHandle, 'lines')</l>
<l>    set_message_tuple (MessageHandle, 'bands', Bands)</l>
<l>    set_message_tuple (MessageHandle, 'samples', Samples)</l>
<l>    enqueue_message (QueueHandle, MessageHandle, [], [])</l>
<l>endfor</l>
<l>set_framegrabber_param (AcqHandle, 'do_abort_grab', 1)</l>
<l>return ()</l>
</body>
<docu id="grab_line_frames">
<parameters>
<parameter id="AcqHandle"/>
<parameter id="Height"/>
<parameter id="NumImages"/>
<parameter id="QueueHandle"/>
</parameters>
</docu>
</procedure>
</hdevelop>
